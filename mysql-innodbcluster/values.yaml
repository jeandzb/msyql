# mysql-server的镜像配置，这里没有router的镜像配置
image:
  registry: registry.cn-beijing.aliyuncs.com
  repository: alphesh-soft
  name: community-server
  tag: "8.0.28"
  pullPolicy: IfNotPresent
  pullSecrets:
    enabled: true
    secretName: registry-aliyun

credentials:
  root:
    user: root
    password: alphesh123
    host: "%"

tls:
  useSelfSigned: true
#  caSecretName:
#  serverCertAndPKsecretName:
#  routerCertAndPKsecretName: # our use router.certAndPKsecretName

serverVersion: 8.0.28
serverInstances: 3
routerInstances: 1 # or use router.instances 设置router的实例数
baseServerId: 1000

# router的服务配置，对mysql服务的负载均衡
#router:
#  instances: 1
#
#  options:
#  - option1: value1
#  - option2: value2
#  bootstrapOptions:
#  - bootstrapOption1: value1
#  - bootstrapOption2: value2
  #  certAndPKsecretName:
  #  #IMPORTANT: Once podSpec is set it is carved into stone. If changed, the router deployment won't be rebuilt. podSpec is
  #  #           respected only when during the initial build of of the Innodbcluster and its Router Deployment. Later changes
  #  #           to the podSpec, in the Chart of directly in the IC CR/object won't be regarded, as the Operator doesn't watch
  #  #           for changes of router.podSpec.
  #  podSpec:
  #    affinity:
  #      podAntiAffinity:
  #        requiredDuringSchedulingIgnoredDuringExecution:
  #        # Ensure Router pods avoid nodes with operator deployment pods
  #        - labelSelector:
  #            matchLabels:
  #              app.kubernetes.io/name: mysql-operator
  #              app.kubernetes.io/instance: myoperator
  #          topologyKey: kubernetes.io/hostname
  #          namespaces: ["mysql-operator"]
  #        # Ensure Router pods avoid nodes with server (STS) pods (change mycluster1 with .Release.Name)
  #        - labelSelector:
  #            matchLabels:
  #              app.kubernetes.io/name: mysql-innodbcluster-mysql-server
  #              app.kubernetes.io/instance: mysql-innodbcluster-mycluster1-mysql-server
  #          topologyKey: kubernetes.io/hostname
  #        # Ensure Router pods are on different nodes from each other (change mycluster1 with .Release.Name)
  #        - labelSelector:
  #            matchLabels:
  #              app.kubernetes.io/name: mysql-router
  #              app.kubernetes.io/instance: mysql-innodbcluster-mycluster1-router
  #          topologyKey: kubernetes.io/hostname
  #  podAnnotations:
  #  podLabels:

# mysql集群内实例间的服务，一般是headless service, 指向的是mysql server的pod
  #instanceService:
  #  annotations:
  #    ann1: "is_avalue1"
  #  labels:
  #    l1: "is_lvalue1"

# 集群主server服务类型,指向的是router的pod,包含多个端口
service:
  type: "NodePort"
  #  annotations:
  #    ann1: "es_avalue1"
  #  labels:
  #    l1: "es_lvalue1"

# 解决pvc数据目录权限问题
  #datadirPermissions:
  # true 则表示在initContainer的pod以root权限运行，给相关目录以mysql进程的用户权限
  #  setRightsUsingInitContainer: false
  # 每次重启pod时都重新设置目录及递归目录的权限
  #  fsGroupChangePolicy: "Always"

  #logs:
  #  error:
  #    enabled: true
  #    collect: false
  #  general:
  #    enabled: false
  #    collect: false
  #  slowQuery:
  #    enabled: false
  #    longQueryTime: 2.5
  #  collector:
  #    image: "192.168.20.198:5000/fluentd-es:v1.16"
  #    fluentd:
  #      forwarding:
  #        enabled: false
  #        forwarderSpec:
  #          podSpec:
  #            terminationGracePeriod: 42
  #          podAnnotations:
  #            forwarderAnnotation1: forwarderAnnotation1Value
  #          podLabels:
  #            forwarderLabel1: forwarderLabel1Value
  #      generalLog:
  #        tag: "genLogTag"
  ##        options:
  #      errorLog:
  #        tag: "errLogTag"
  ##        options:
  ##      slowLog:
  #        tag: "slowLogTag"
  ##        options:
  #     recordAugmentation:
  #        enabled: false
  #        labels:
  #        - fieldName: "pod_name"
  #          labelName: "statefulset.kubernetes.io/pod-name"
  #        annotations:
  #        - fieldName: "membership-info"
  #          labelName: "mysql.oracle.com/membership-info"
  #        staticFields:
  #        - fieldName: "static_field_1"
  #          fieldValue: "static_field_1_value"
  #        resourceFields:
  #        - fieldName: "pod_ip"
  #          fieldPath: "status.podIP"
  #        - fieldName: "host_ip"
  #          fieldPath: "status.hostIP"
  #      additionalFilterConfiguration: |
  #        filterConfigValueLine1
  #        filterConfigValueLine1
  #      sink:
  ##       rawConfig:

# 数据静态加密配置
  #keyring:
  #  file:
  #    fileName:
  #    readOnly:
  #    storage:
  #  encryptedFile:
  #    fileName:
  #    readOnly:
  #    storage:
  #    password:
  #  hashicorp:
  #    caCertificates: "configmap-name"
  #    caching: false
  #    serverUrl: "https://...."
  #    storePath: "/v1/kv/..."
  #    auth:
  #      approle: # either approle ...
  #        authSecret: "secret-name"
  #        authenticationPath: "/v1/auth/approle/login"
  #     token: # ... or token
  #       tokenSecret: "secret-name"
  #  oci:
  #    user: "ocid1.user.oc1..."
  #    keySecret: "oci-credentials"
  #    keyFingerprint: ""
  #    tenancy: "ocid1.tenancy.oc1..."
  #    compartment: "ocid1.compartment.oc1..."
  #    virtualVault: "ocid1.vault.oc1.."
  #    masterKey: "ocid1.key.oc1..."
  #    caCertificate: ""
  #    endpoints:
  #      encryption: "<identifier>-crypto.kms.<region>.oraclecloud.com"
  #      management: "<identifier>-management.kms.<region>.oraclecloud.com"
  #      vaults: "vaults.<region>.oci.oraclecloud.com"
  #      secrets: "secrets.vaults.<region>.oci.oraclecloud.com"


  #IMPORTANT: Once podSpec is set it is carved into stone. If changed, the IC StatefulSet won't be rebuilt. podSpec is
  #           respected only when during the initial build of of the Innodbcluster. Later changes to the podSpec, in the Chart
  #           of directly in the IC CR/object won't be regarded, as the Operator doesn't watch for changes of podSpec.

# mysql-server的pod规格配置
podSpec:
  containers:
  - name: mysql
    image: "registry.cn-beijing.aliyuncs.com/alphesh-soft/community-server:8.0.28"
    # 调整 Glibc 内存分配器
    env:
      - name: MALLOC_ARENA_MAX
        value: "4"
    resources:
      requests:
        memory: "2048Mi"  # adapt to your needs
        cpu: "1800m"      # adapt to your needs
      limits:
        memory: "4069Mi"  # adapt to your needs
        cpu: "3600m"      # adapt to your needs
  - name: sidecar
    image: "registry.cn-beijing.aliyuncs.com/alphesh-soft/community-operator:9.5.0-2.2.6"
  initContainers:
    - name: fixdatadir
      image: "registry.cn-beijing.aliyuncs.com/alphesh-soft/community-operator:9.5.0-2.2.6"
    - name: initconf
      image: "registry.cn-beijing.aliyuncs.com/alphesh-soft/community-operator:9.5.0-2.2.6"
    - name: initmysql
      image: "registry.cn-beijing.aliyuncs.com/alphesh-soft/community-server:8.0.28"
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
 # Ensure STS pods avoid nodes with operator deployment pods
#      - labelSelector:
#          matchLabels:
#            app.kubernetes.io/name: mysql-operator
#            app.kubernetes.io/instance: myoperator
#        topologyKey: kubernetes.io/hostname
#      namespaces: ["mysql"]
# Ensure STS pods are on different nodes from each other (change mycluster1 with .Release.Name)需要修改下面mysqlcluster的值为当前的Release.Name
      - labelSelector:
          matchLabels:
            app.kubernetes.io/instance: mysql-innodbcluster-mysqlcluster-mysql-server
        topologyKey: kubernetes.io/hostname

#podAnnotations:
#podLabels:

serverConfig:
  mycnf: |
    [mysqld]
    sql_mode = "STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,ONLY_FULL_GROUP_BY,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO"
    character_set_server = utf8mb4
    collation_server = utf8mb4_0900_ai_ci
    max_connections = 512
    max_allowed_packet = 128M
    innodb_buffer_pool_size = 50%
    innodb_log_file_size = 1G
    innodb_log_files_in_group = 2
    innodb_flush_log_at_trx_commit = 1
    innodb_flush_method = O_DIRECT
    innodb_io_capacity = 200
    innodb_io_capacity_max = 400
    innodb_flush_neighbors = 1
    innodb_lru_scan_depth = 512
    innodb_file_per_table = 1
    innodb_monitor_enable = all
    wait_timeout = 600
    interactive_timeout = 600
    performance_schema = OFF
    sync_binlog = 1
    binlog_transaction_dependency_tracking = WRITESET
    binlog_row_image = FULL
    group_replication_consistency = BEFORE_ON_PRIMARY_FAILOVER
    slow_query_log = 1
    long_query_time = 1
    log_error_verbosity = 2

# --- 5. 存储配置 ---
datadirVolumeClaimTemplate:
  storageClassName: "nfs-client"
  accessModes: "ReadWriteOnce"
  resources:
    requests:
      storage: "100Gi"

# --- 6. 初始化数据库 --- 告诉 MySQL Operator：当它部署一个新的 MySQL Cluster 时，应该如何填充（Initialize）数据，而不是从一个空集群开始，下面提供两种方式：dump 或 clone。首次部署全新环境，不需要此配置。
#initDB:
#  dump:
#    name:
#    path:
#    options:
#      includeSchemas:
#    ociObjectStorage:
#      prefix:
#      bucketName:
#      credentials:
#    s3:
#      prefix:
#      config:
#      bucketName:
#      profile:
#      endpoint
#    azure:
#      prefix:
#      config:
#      containerName:
#    persistentVolumeClaim:
#  clone:
#    donorUrl:
#    rootUser:
#    credentials:

# 备份配置，包含dump逻辑备份和snapshot快照备份,以及备份文件存储位置
# 逻辑备份，数据存储到节点的pvc
backupProfiles:
#- name: dump-instance-profile-pvc
#  dumpInstance:
#    dumpOptions:
#      excludeSchemas: ["excludeme"]
#    storage:
#      persistentVolumeClaim:
#        claimName: backup-volume-claim-1

# 逻辑备份，数据转存到Storage
- name: dump-instance-profile-nfs
  dumpInstance: # 备份所有非系统数据库
    dumpOptions:
      # excludeSchemas: ["excludeme"]  # 排除指定的数据库
    storage:
      persistentVolumeClaim:
        claimName: nfs-backup-claim

# 快照备份并上传到OCI Object Storage
#- name: snapshot-profile-oci
#  snapshot:
#    storage:
#      ociObjectStorage:
#        prefix : /
#        bucketName: idbcluster_backup
#        credentials: oci-credentials
#      s3:
#        prefix:
#        config:
#        bucketName:
#        profile:
#        endpoint
#      azure:
#        prefix:
#        config:
#        containerName:

# --- 7. 备份计划 --- 定义备份的执行频率、时间和存储位置。可以配置多个备份计划，每个计划对应不同的备份策略（如 dump 或 snapshot）。
backupSchedules:
- name: schedule-ref
  schedule: "0 4 * * *"
  timeZone: "Asia/Shanghai"
  deleteBackupData: false
  backupProfileName: dump-instance-profile-nfs
  enabled: true

# 直接在调度中定义备份策略和存储。考量： 这种方式导致配置重复且难以维护，不推荐在生产环境使用。
#- name: schedule-inline
#  schedule: "*/1 * * * *"
#  timeZone: "Europe/Amsterdam"
#  deleteBackupData: false
#  enabled: true
#  backupProfile:
#    dumpInstance:
#      dumpOptions:
#        excludeSchemas: ["excludeme"]
#      storage:
#        ociObjectStorage:
#          prefix : /
#          bucketName: idbcluster_backup
#          credentials: oci-credentials


# If you would like to debug the Helm output with `helm template`, you need
# to turn disableLookups on as during `helm template` Helm won't contact the kube API
# and all lookups will thus fail
disableLookups: false

# Set explicit FQDN for MySQL instances
# serviceFqdnTemplate: "{service}.{namespace}.svc.{domain}"
